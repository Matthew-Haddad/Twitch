#include <Arduino_LSM9DS1.h>
#include <aifes.h>

#define NUM_SAMPLES 20  //15 30
#define NUM_AXES 3
#define TRUNCATE 20
#define ACCEL_THRESHOLD 4 //5
#define INTERVAL 30

#define SAMPLES_PER_CLASS 5

#define NUMBER_OF_DATA  3 * SAMPLES_PER_CLASS

// Defines for AIfES FNN
#define FNN_3_LAYERS    3
#define INPUTS          NUM_SAMPLES * NUM_AXES
#define NEURONS         4 
#define OUTPUTS         3 // 3 gestures
#define PRINT_INTERVAL  10

// FNN structure
uint32_t FNN_structure[FNN_3_LAYERS] = {INPUTS,NEURONS,OUTPUTS};

// Activation functions
AIFES_E_activations FNN_activations[FNN_3_LAYERS - 1];

// Pointer for the weights
float *FlatWeights;

// AIfES-Express model parameter
AIFES_E_model_parameter_fnn_f32 FNN;

// Baseline for calibration
float baseline[NUM_AXES];

// Features (inputs) of a single gesture
float features[INPUTS];

// Array for the labels (outputs)of a single gesture
// Three gestures can be trained
// 1,0,0 --> gesture 1
// 0,1,0 --> gesture 2
// 0,0,1 --> gesture 3
int labels_print[3] = {1,0,0};

// 2D array for training (inputs)
// Here the features of the gestures from the data recording are stored
float training_data[NUMBER_OF_DATA][INPUTS];

// 2d array for training (target data/labels)
// Here the labels of the gestures from the data recording are stored
float labels[NUMBER_OF_DATA][OUTPUTS];

int training_data_counter = 0;

int class_counter = 0;

// Counter for the samples per gesture (5 samples per gesture)
int sample_counter = 0;

uint32_t global_epoch_counter = 0;

void setup() {
  Serial.begin(115200);
  while (!Serial);
  Serial.println("AIfES simple gesture recognition demo");
  Serial.println("Data recording Mode:");
  Serial.print(NUM_SAMPLES * NUM_AXES);
  Serial.println(" features and 3 gestures");
  Serial.println("Make sure that the board is always held in the same position in your hand!");

  if (!IMU.begin()) {
    Serial.println("Failed to initialize IMU!");
    while (1);
  }

  //IMPORTANT
  //AIfES requires random weights for training
  //Here the random seed is generated by the noise of an analog pin
  srand(analogRead(A5));

  // Gravity calibration
  //calibrate();
  
  float ax, ay, az; 

}

void loop() {
  // Gravity calibration
  //calibrate();
  
  float ax, ay, az; 

  Serial.println("Repeat the first gesture five times!");

  bool motion_detected = false;

  while(class_counter <= (OUTPUTS - 1)){
    // Wait for the acceleration to be higher than the threshold 
    while(!motion_detected){        
        if (IMU.accelerationAvailable()) {
          IMU.readAcceleration(ax, ay, az);
        }
        
        ax = constrain(ax - baseline[0], -TRUNCATE, TRUNCATE);
        ay = constrain(ay - baseline[1], -TRUNCATE, TRUNCATE);
        az = constrain(az - baseline[2], -TRUNCATE, TRUNCATE);
  
    
        if (motionDetected(ax, ay, az)) {
          motion_detected = true;
        }
        else{
          delay(10);
        }
    }

    if(class_counter <= (OUTPUTS - 1)){
      recordIMU();
      printAndSafeFeatures();
      motion_detected = false;
    }


    sample_counter = sample_counter + 1;
    training_data_counter = training_data_counter + 1;
    
    if(sample_counter == SAMPLES_PER_CLASS){
      sample_counter = 0;
      class_counter = class_counter + 1;
      
      if(class_counter == 1){
        Serial.println("Repeat the second gesture five times!");
        labels_print[0] = 0;
        labels_print[1] = 1;
        labels_print[2] = 0;
      }
      if(class_counter == 2){
        Serial.println("Repeat the third gesture five times!");
        labels_print[0] = 0;
        labels_print[1] = 0;
        labels_print[2] = 1;
      }
      if(class_counter > 2){
        Serial.println("Data recording finished!");
      }
      
    }

    delay(50);
  }

  // This is where the AIfES model is built. The function is defined in the tab creation_and_training.
  // The different layers are defined and storage is reserved for the trainable parameters (like weights, bias, ...) of the model.
  build_AIfES_model();

  //A simple countdown to give the user time to read the UART outputs
  //countdown();

  // The AIfES model is trained with the captured data. This function is also defined in the tab creation_and_training
  // Not only is the training carried out here, but also the necessary memory is reserved for intermediate results, gradients and moments of the training and the results of the training are displayed
  train_AIfES_model();
}
